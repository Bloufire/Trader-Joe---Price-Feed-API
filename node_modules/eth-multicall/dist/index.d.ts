import Web3 from "web3";
export interface Options {
    web3: Web3;
    chunkSizes?: number[];
    multiCallContract: string;
    strict: boolean;
}
export interface CallReturn<T = any> {
    arguments: any[];
    _method: {
        outputs: {
            name: string;
            type: string;
        }[];
    };
    _parent: {
        _address: string;
    };
    call: (options?: {}, blockHeight?: number) => Promise<T>;
    encodeABI: () => string;
}
export declare type MultiCallItem = [string, string];
export declare type MultiCallReturn = [string, {
    success: boolean;
    data: string;
}];
export interface ShapeWithLabel {
    [item: string]: CallReturn | string;
}
export interface Shape {
    [item: string]: CallReturn;
}
export interface AbiEncodedShape {
    originAddress: string;
    data: {
        [item: string]: string;
    };
}
export declare enum DataTypes {
    originAddress = "originAddress"
}
export interface UserCallOptions {
    skipDecode?: boolean;
    traditional?: boolean;
    blockHeight?: number;
}
export declare class MultiCall {
    web3: Web3;
    contract: string;
    chunkSizes: number[];
    constructor(web3: Web3, contract?: string, chunkSizes?: number[]);
    rawCall(calls: MultiCallItem[], strict?: boolean, blockHeight?: number): Promise<MultiCallReturn[]>;
    multiCallGroups(calls: MultiCallItem[][], blockHeight?: number): Promise<MultiCallReturn[][]>;
    rawCallInChunks(calls: MultiCallItem[], chunkSizes: number[], blockHeight?: number): Promise<MultiCallReturn[]>;
    private decodeHex;
    private normalCall;
    private encodeAbi;
    stripLabels(groupsOfShapes: ShapeWithLabel[][]): Shape[][];
    recoverLabels(original: ShapeWithLabel[][], withData: any[][]): any[][];
    all(groupsOfShapes: ShapeWithLabel[][], passedOptions?: UserCallOptions): Promise<any[][]>;
}
